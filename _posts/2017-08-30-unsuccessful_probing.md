---
title: Unsuccessful probing
layout: post
category: myOS
---

I have implemented enumeration methods for PCI buses. PCI refers to Peripheral Component Interconnect which is a standard for attaching hardware to the computer. Each slot that contains hardware (HDDs,GPUs, Ethernet etc.) is assigned a unique bus, device and function numbers. According to Wikipedia:

```To address a PCI device, it must be enabled by being mapped into the system's I/O port address space or memory-mapped address space. The system's firmware, device drivers or the``` ```operating system program the Base Address Registers (commonly called BARs) to inform the device of its address mapping by writing configuration commands to the PCI controller. Because all PCI devices are in an inactive state upon system reset, they will have no addresses assigned to them by which the operating system or device drivers can communicate with them. Either the BIOS or the operating system geographically addresses the PCI slots (for example, the first PCI slot, the second PCI slot, or the third PCI slot, etc., on the motherboard) through the PCI controller using the per slot IDSEL (Initialization Device Select) signals. Since there is no direct method for the BIOS or operating system to determine which PCI slots have devices installed (nor which functions the device implements) the PCI bus(es) must be enumerated...```<a href="https://en.wikipedia.org/wiki/PCI_configuration_space#Bus_enumeration">more</a>

After the enumeration is done, I am able to identify the virtual <a href="https://en.wikipedia.org/wiki/Advanced_Host_Controller_Interface">AHCI</a> controller that is added with QEMU. Unfortunately, both in Virtualbox and QEMU, I am unable to detect the virtual SATA drives attached to the AHCI controller. And I have tried all the debugging steps the internet has to offer and no result. I think the culprit here is the virtual memory manager that is not working as expected. 

So, I leave AHCI there and start working on implementing VGA graphics mode as it was looking very simple and straight-forward. But guess what? It didn't work. I followed all the steps from a video of a working implementation and the mode is not getting switched from text to graphics. I think the reason here is the host OS (Ubuntu 16.04) in my case. As there has beem a discussion on Stackoverflow where one of the answers mentioned that changing the value of VGA registers might not be supported in the user mode of the host OS. The video where I saw the code working is very old and probably the OS he used didn't restrict the code. It's either that or unsupported hardware. Both the reasons have the same solution: use the BIOS function INT 10h. The only problem is the function is not supported in protected mode my OS will be in most of the time. So, to use that function, I have to temporarily shift to Virtual 8086 Mode, trigger the interrupt and go back to the protected mode.